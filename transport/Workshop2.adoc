= Workshop Part 1: Track a packet on the blockchain
:toc: preamble
:experimental:

The goal of this part is to implement a simple application that tracks sensor measurements on the blockchain.
That means, once the IoT application will be started, it will immediately send an `LightAlarmTransaction` to the network, whenever the sensor detects light.

You will learn here:

* How to implement the `LightAlarmTransaction`
* How to register the new transaction type with the node application
* How to create the IoT script, and how to put it on the Raspberry Pi
* How to use the client app to initialize the packet account and to track the alarm transactions in the network

****

[TIP]
====
xref:transactions/solutions/light-alarm.js[You can always checkout the solutions at /transactions/solutions] for the custom transaction types.

You can also require the solutions directly in your app, just change

[source,js]
----
const LightAlarmTransaction = require('../transactions/light-alarm');
----

To

[source,js]
----
const LightAlarmTransaction = require('../transactions/solutions/light-alarm');
----

But let's try not to cheat too much ;-)
====

****

== Project Architecture

Three different kind of applications need to be developed, to create the decentralized supply chain system:

A node application::
which accepts the application-specific transaction types.
This application needs to be installed on different independent nodes and will setup and maintain the blockchain which is used to store the data about the packets, carrier and users.

A client application::
which is displaying information from the blockchain to the user.
It needs a frontend, which should be listing at least a list of packetIDs, the carrier, sender, recipient, and a status field (`pending | ongoing | alarm | success | fail`).
It should also provide an easy way to create and send the different transaction types to the network.

An IoT application::
which is stored on a microcontroller/raspberry pi. This application will track that the packet is not manipulated during the delivery.
To do this, certain sensors will be connected to it, that track information like light, temperature and/or humidity inside of the packet.
If something unexpected is detected by the IoT app, it will create a transaction object, sign it, and send it to the network.

The basic file structure looks as following (contents of `lisk-sdk-examples/transport`):
----
.
├── README.adoc
├── Workshop.adoc
├── client                                          <1>
│   ├── accounts.json
│   ├── app.js
│   ├── package.json
│   ├── scripts
│   └── views
├── iot                                             <2>
│   ├── README.md
│   ├── lisk_rpi_ldr_and_temperature_sensors_wiring.png
│   ├── light_alarm
│   │   ├── package.json
│   │   └── index.js
├── node                                            <3>
│   ├── index.js
│   └── package.json
└── transactions                                    <4>
    ├── finish-transport.js
    ├── light-alarm.js
    ├── register-packet.js
    └── start-transport.js
----

<1> Contains the code for the <<project-architecture, client application>>
<2> Contains the code for the <<project-architecture, IoT application>>
<3> Contains the code for the <<project-architecture, node application>>
<4> Contains the custom transactions, that are used by the node and client app.

== 1.1 Implement the LightAlarm transaction

For the very simple version of the packet tracking, only one custom transaction type needs to be implemented: the `LightAlarmTransaction`.
This transaction will be sent by the IoT device inside of the packet when it detects anomalies with its connected photoresistor (light detection).

The only thing you need to implement in this step yourself is the `validateAsset` function. For more details how to do this, check the <<task-implement-validateasset, explanation below>>. The code you see below represents the current state for which you'll have to implement the `validateAsset()` function.

.Contents of `/transactions/light-alarm.js`
[source,js]
----
const {
    BaseTransaction,
    TransactionError,
} = require('@liskhq/lisk-transactions');

/**
 * Send light alarm transaction when the packet has been opened (accepts timestamp).
 * Self-signed by packet.
 * The `LightAlarmTransaction` is extended from the `BaseTransaction` interface.
 */
class LightAlarmTransaction extends BaseTransaction {

    /* Static property that defines the transaction `type` (has to be unique in the network). */
    static get TYPE () {
        return 23;
    }

    /* The transaction `fee`. This needs to be paid by the sender when posting the transaction to the network.
       It is set to `0`, so the packet doesn't need any funds to send an alarm transaction. */
    static get FEE () {
        return '0';
    };

    /* Data from the packet account is cached from the databse. */
    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId,
            }
        ]);
    }

    /* Static checks for presence and correct datatype of `timestamp`, which holds the timestamp of when the alarm was triggered. */
    validateAsset() {
        const errors = [];
        /*
        Implement your own logic here.
        Static checks for presence of `timestamp` which holds the timestamp of when the alarm was triggered
        */

        return errors;
    }

    applyAsset(store) {
        /* Insert the logic for applyAsset() here */
    }

    undoAsset(store) {
        const errors = [];
        const packet = store.account.get(this.senderId);

        /* --- Revert packet status --- */
        packet.asset.status = null;
        packet.asset.alarms.light.pop();

        store.account.set(packet.address, packet);
        return errors;
    }

}

module.exports = LightAlarmTransaction;
----

TIP: Go to the Lisk Documentation, to get an https://lisk.io/documentation/lisk-sdk/customize.html#_the_basetransaction_interface[overview about the required methods for custom transactions]

=== 1.1.1 Task: Implement `validateAsset()`

Implement your own logic for the `validateAsset()` function xref:transactions/light-alarm.js#L31[here at line 31].
The code will validate the timestamp that has been sent by the `LightAlarmTransaction`.
In case an error is found, push a new `TransactionError` into the `errors` array and return it at the end of the function.

TIP: All data, that is sent with the transaction is available through the `this` variable. So, to access the timestamp of the transaction, use `this.timestamp`.

The snippet below describes how to create an `TransactionError` object. Try to add a fitting `TransactionError` to the `errors` list of `validateAsset()`, in case the timestamp is not present, or if it has the wrong format.

NOTE: The expected data type for the timestamp is `number`!

.Example: How to create a `TransactionError` object:
[source, js]
----
new TransactionError(
	'Invalid "asset.hello" defined on transaction',
	this.id,
	'.asset.hello',
	this.asset.hello,
	'A string value no longer than 64 characters',
)
----

TIP: In case you need some inspiration how to implement the `validateAsset()` function, check out the other examples like `hello_world` inside of the `lisk-sdk-examples` repository, or check the https://lisk.io/documentation/lisk-sdk/tutorials/hello-world.html#_3_create_a_new_transaction_type[tutorials] in the Lisk documentation.

**Important: To verify your implementation of `validateAsset()`, compare it with the xref:transactions/solutions/light-alarm.js[solution].**

=== 1.1.2 Task: Implement `applyAsset()`

The `applyAsset` function tells the blockchain what changes it should make and how to change a user's account. Basically, it holds the core business logic of your custom transaction. The magic happens here! You can find a possible implementation of `applyAsset` for the `LightAlarmTransaction` below. 

**Copy the snippet below and replace the `applyAsset` function in `light-alarm.js` with it in order to complete the implementation of the lightAlarmTransaction.**

[source,js]
----
/*Inside of `applyAsset`, we can make use of the cached data from the `prepare` function,
 * which is stored inside of the `store` parameter.*/
applyAsset(store) {
    const errors = [];

    /* With `store.account.get(ADDRESS)` we now get the account data of the packet account.
     * We specify `this.senderId` as address, because the light alarm is always signed and sent by the packet itself. */
    const packet = store.account.get(this.senderId);

    /**
     * Update the Packet account:
     * - set packet status to "alarm"
     * - add current timestamp to light alarms list
     */
    packet.asset.status = 'alarm';
    packet.asset.alarms = packet.asset.alarms ? packet.asset.alarms : {};
    packet.asset.alarms.light = packet.asset.alarms.light ? packet.asset.alarms.light : [];
    packet.asset.alarms.light.push(this.timestamp);

    /* When all changes have been made, they are applied to the database by executing `store.account.set(ADDRESS, DATA)`; */
    store.account.set(packet.address, packet);

    /* Unlike in `validateAsset`, the `store` parameter is present here.
     * That means, inside of `applyAsset` it is possible to make dynamic checks against the existing data in the database.
     *  As we do not need to this here, an empty `errors` array is returned at the end of the function. */
    return errors;
}
----

=== 1.1.3 Register the transaction with the application

Now, that we have created the new custom transaction type `LightAlarmTransaction`, it needs to be registered with the node application. Without this step, the nodes won't have the logic to validate a `LightAlarmTransaction` and the transaction will be discarded.

.Check out the code at `node/index.js` which registers the LightAlarmTransaction to the blockchain application:
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
const LightAlarmTransaction = require('../transactions/light-alarm');           <1>

configDevnet.app.label = 'lisk-transport';

const app = new Application(genesisBlockDevnet, configDevnet);

app.registerTransaction(LightAlarmTransaction);                                 <2>

app
    .run()
    .then(() => app.logger.info('App started...'))
    .catch(error => {
        console.error('Faced error in application', error);
        process.exit(1);
    });
----

<1> Requires the custom transaction type.
<2> Registers the custom transaction type with the application.

NOTE: After the registration of a new transaction type, the node needs to be restarted to apply the changes with `node index.js | npx bunyan -o short`. Make sure you are executing this command inside the `/node` folder.

== 1.2 The IoT application

In this step we are going to create the script that will run on the Raspberry Pi to track if the packet has been manipulated.

=== 1.2.1 Connect to the Raspberry Pi

Connect a micro usb cable with the Raspberry and then connect the other end to a computer. **Make sure you connect the micro usb cable to the port that has a small label `usb` above it.**

image:assets/usb-port.jpg[How to connect to your Pi]

You should be able to log-in through `ssh` by running:

[source, bash]
----
ssh pi@10.10.10.10
----

If the pi won't respond, press kbd:[CTRL+C] and try the last command again.
If prompted with a warning just hit enter to accept the default (Yes).

Following, it will ask for the password. Type in the password **which is printed on the box of your Raspberry Pi.**

Your terminal should now be connected to the Raspberry Pi. In the next step, we will be working on the Raspberry Pi in order to prepare the device.

=== 1.2.2 Create the tracking script
Execute the below commands for creating the tracking script:
[source,bash]
----
mkdir light_alarm #Create a folder to hold the tracking script.
cd light_alarm
npm init --yes #Creates the `package.json` file.
npm i @liskhq/lisk-transactions @liskhq/lisk-api-client @liskhq/lisk-constants rpi-pins #Install dependencies.							<5>
----

Now, create a new file called `light-alarm.js`.

[source,bash]
----
touch light-alarm.js
----

Next, **copy the code from your local computer** at `transport/transactions/light-alarm.js` (which we prepared in <<1-1-implement-the-lightalarm-transaction, step 1.1>>) to the Raspberry Pi. First, let's open the file with the `nano` editor.

[source,bash]
----
nano light-alarm.js
----

Next, insert here the code of the `LightAlarmTransaction`. You can use `CMD + V` to paste the contents in the file.
In order to save and exit `nano`, use:

[source,bash]
----
CMD + O
ENTER
CMD + X
----

The second file you need to create is the actual tracking script. Create a new file `index.js` that will hold our tracking script.

[source,bash]
----
touch index.js
----

Next, **insert the code snippet below** and save the `index.js` file. You can reuse the above commands with the `nano` editor.

[source,js]
----
const PIN = require("rpi-pins");
const GPIO = new PIN.GPIO();
// Rpi-pins uses the WiringPi pin numbering system (check https://pinout.xyz/pinout/pin16_gpio23).
GPIO.setPin(4, PIN.MODE.INPUT);
const LightAlarmTransaction = require('./light-alarm');
const { APIClient } = require('@liskhq/lisk-api-client');

// Replace `localhost` with the IP of the node you want to reach for API requests.
const api = new APIClient(['http://localhost:4000']);

// Check config file or visit localhost:4000/api/node/constants to verify your epoc time (OK when using /transport/node/index.js)
const dateToLiskEpochTimestamp = date => (
    Math.floor(new Date(date).getTime() / 1000) - Math.floor(new Date(Date.UTC(2016, 4, 24, 17, 0, 0, 0)).getTime() / 1000)
);

const packetCredentials = { /* Insert the credentials of the packet here in step 1.3 */ }

// Check the status of the sensor in a certain intervall (here: 1 second).
setInterval(() => {
	let state = GPIO.read(4);
	if(state === 0) {
		console.log('Package has been opened! Send lisk transaction!');
        // Uncomment the below code in step 1.3 of the workshop
        /*let tx =  new LightAlarmTransaction({
            timestamp: dateToLiskEpochTimestamp(new Date())
        });

        tx.sign(packetCredentials.passphrase);

        api.transactions.broadcast(tx.toJSON()).then(res => {
            console.log("++++++++++++++++ API Response +++++++++++++++++");
            console.log(res.data);
            console.log("++++++++++++++++ Transaction Payload +++++++++++++++++");
            console.log(tx.stringify());
            console.log("++++++++++++++++ End Script +++++++++++++++++");
        }).catch(err => {
            console.log(JSON.stringify(err.errors, null, 2));
        });*/
	} else {
		console.log('Alles gut');
	}
}, 1000);

----

=== Run the tracking script

To check if the script can read the sensor data, uncomment the `console.log` statements in the trakcing script and start the script by running:

[source, bash]
----
node index.js
----

Now place the sensor in a dark place and then in a light place, and verify the correct logs are shown in the console.

If no light is detected, it should log `Alles gut`, and if light is detected, it will log `Package has been opened! Send lisk transaction!`.

It will also try to send the light alarm transaction in case it detects light.
This will fail, as we didn't provide the passphrase of the packet in the script, which is needed to sign the `LightAlarmTransaction`.

Let's use the client app in the next step 1.3 to initialize a new account for the packet.
We can then store the passphrase on the raspberry pi and explore the send alarm transaction through the client app.

== 1.3 The client application

While your Raspberry Pi is still connected, open a local terminal window and navigate into the `client` app.

[NOTE]
====
The complete implementation of the client is prepared for you before the workshop.
In Part 1, we will only make use of the `Initialize` and `Packet&Carrier` pages.
====

[source, bash]
----
cd ../client
npm i
node app.js
----

.Navigate to the `Initialize` page to create a new packet account
image:assets/initialize-step1.png[Initialization of the packet account]

Every time that you refresh the page, new packet credentials are created and initialized in the network.

Copy the object with the credentials and past it as `packetCredentials` in your <<create-the-tracking-script, tracking script>> on the Raspberry Pi.
The Raspberry has now the power to identify itself with the network, by signing the transaction with it's secret passphrase, before sending it to the network.

To now track the light alarm with the client application, do the following:

. To start the node application, run this inside of the `node` folder:
+
[source, bash]
----
node index.js | npx bunyan -o short
----
. to start the client, run this inside the `client` folder:
+
[source, bash]
----
node app.js
----
. Put the sensor of your raspberry in a dark place.
. Now, start the tracking script on your raspberry pi:
+
[source, bash]
----
node index.js
----
. Go to the `Packet&Carrier` page and refresh.
Nothing should be shown on the page, yet.
. Now, shed some light on the sensor, and refresh the page again
. If you refresh again, you should see a list of light alarm transaction object, that just got sent by the Raspberry Pi.

If you see the timestamps are added to `asset.alarms.light` of the packet account, you have successfully completed Part 1 of the workshop, congratz! \o/

image:assets/packet-carrier-step1.png[packet account]

[NOTE]
====
You are now able to detect a packet manipulation and to save a corresponding record on the blockchain.

xref:Workshop3.adoc[Click here to continue with Part 2: Create a simple supply chain system]
====
