= Workshop: Lisk Transport
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:experimental:

== Motivation

One reason why the modern world is seeing more and more wealth created is because the economies and markets are connected via ever more sophisticated routes of global trade.
Whether be it by air, sea, or road, billions worth of goods are being taken from continent to continent every single day, in order to satisfy demand and meet supply quotas.
However, while new methods of storage and route tweaks are still developed in order to further propel this vital aspect of the global economy, the sheer volume of transport information processed on a daily basis means there is huge inaccuracy of data when trying to monitor an individual product’s journey.
Major business leaders depending on physical supply chains have long pushed for more transparency, price-efficiency and data insight, starting at the creation of a product to its final destination.

Applying blockchain to a supply chain could resolve these problems by creating a permanent history of a product.
This can have many industry-spanning benefits - reducing costs, pinpointing human error and avoiding delays.
All of this could potentially save years of time and billions of dollars in overhead.
Vendors and suppliers could benefit from a greater insight into the manufacturing process of the goods they use, being able to use the decentralized supply ledger in order to investigate variables such as delivery or maintenance of products.
For certain industries where high maintenance of goods in the supply chain is especially crucial, we can envision how blockchain can step in in order to ensure that quality targets are being met.
For example, medical or aerospace science industries could easily utilise blockchain supply chain in order to ensure the parts and chemicals they use in their work come from a reputable source and have had all the necessary storage requirements met in the journey to its final destination.

Retail giants on another hand, can be one of the primary examples of blockchain use cases if we consider how the immutable, trustless nature of a supply chain can be used to crack down on the ethical implications of how some of the raw foods are being sourced, but also improve quality and investigate where the spoiled food came from and how it got on the store shelf.
Insights like these help today’s retailers improve storage and farming techniques in order to raise the food standard for the end customer as well as reduce the amount of food waste that does not meet contemporary health and safety regulation requirements.

image::blockchain-supply-chain.jpg[Blockchain Supply Chain]

=== Conclusion

To conclude, blockchain can benefit supply chain and transport industries by introducing a new level of data transparency and responsiveness that helps to improve processes and attracts potential clients.
On another hand, applying blockchain to certain supply chains can benefit the end consumer, primary producer, and any other party inbetween, through better insights about how any product came to be.

Supply chains of the future are poised to continue being more responsive, efficient and flexible than their contemporaries.
With the global trade networks at stake, blockchain will help flesh out the correct pathways for goods to travel from continent to continent and from producer to end customer.

== Idea

The goal is to create a simple decentralized supply chain tracking system.
The participants of the network can send, transport and receive packets with each other.

For the transportation of the packet, a simple trust system is implemented, that enables the sender to set certain requirements for the carrier of the packet.
The packet as well will be an active participant in the transportation process, as it will track itself with sensors during the transportation.
This is to ensure, that it hasn't been manipulated during the transport.

The carrier will be rewarded upon successful transportation, and penalized if the transportation has failed for some reason.

For convenient usage of the system, a client application will be provided, that visualizes all relevant information about the supply chain tracking system, and that let's users interact with the system by posting custom transactions.

=== General procedure

This diagram shows the general workflow of the supply chain tracking system.
You find detailed descriptions of each step below.

image::transport-uml.svg[Flow chart of Lisk Transport]

==== Initliaze packet account

Before registering the packet on the network, the sender needs to create a new account for the packet and store the passphrase on the IoT device inside the packet.
This is necessary, because the packet needs to sign the transactions it sends to the network, in order to communicate with it.

==== Register packet

The packets are registered on the blockchain network by the packet sender.

When creating the `RegisterPacketTransaction`, the sender defines:

* `packetId`: The ID of the packet that has been initialized in the step before.
* `postage`: This amount will be paid to the carrier for the transport of the packet.
* `security`: The security is the amount of tokens that will be locked on the carrier account, when the carrier receives the packet form the sender
* `minTrust`: The minimum amount of trust a carrier needs to have, to transport this packet
* `recipientId`: The ID of the desired recipient of the packet. Only the recipient can send the `FinishTransaction` later, which will finish the transport.

This transaction will:

 * add the above data to the packet account.
 * set the `status` of the packet to `pending`.
 * transfer the postage from the senders' account to the packet account.

==== Start transport

As next step, a carrier would go to the packet senders' address, receive the packet and start the delivery to the recipient.
The carrier needs to sign a transaction `StartTransportTransaction`, that verifies that the packet has been passed on to the carrier.

When creating the `StartTransportTransaction`, the carrier defines:

* `packetID`: The ID of the packet that the carrier is going to transport.

This transaction will:

* lock the specified `security` of the packet in the carriers' account.
This security cannot be accessed by the carrier, unless the transport has been finished successfully.
* add the `carrier` to the packet account.
* set the `status` of the packet from `pending` to `ongoing`.

==== Light alarm

During the transportation of the packet, the packet will track itself with different sensors, to check if it gets manipulated during the travel.
If a manipulation is detected, it will send a self-signed alarm transaction to the network.

This `LightAlarmTransaction` will:

* change the packets' `status` to `alarm`
* Add the current `timestamp` to the list `asset.alarms.light` inside of the packet account.

==== Finish transport

When reaching the recipient of the packet, the carrier passes the packet to the recipient.
The recipient needs to sign the `FinishTransportTransaction`, that verifies that the packet has been passed on to the recipient.

When sending the transaction, the recipient needs to specify:

* `packetID`: The ID of the packet that the recipient received
* `status`: The status of the transport, which has 2 options: `"success"` or `"fail"`

This transaction will:

* If `status="success"`
** Send `postage` to carrier account
** Unlock `security` in carrier account
** Increase `trust` of carrier +1
** Set packet `status` to `success`
* If `status="fail"`
** Send `postage` to sender account
** Add `security` to the sender account, and nullify `lockedSecurity` from the account fo the carrier.
** Decrease `trust` of carrier by -1
** Set packet `status` to `fail`

== Requirements

=== Hardware

==== Hardware to bring yourself
* Laptop with one of the following OS installed:
** Ubuntu 16.04 (LTS) x86_64
** Ubuntu 18.04 (LTS) x86_64
** MacOS 10.13 (High Sierra)
** MacOS 10.14 (Mojave)

==== Hardware provided
* Raspberry Pi Zero W (running a headless Raspbian Buster lite)
* 16GB class 10 SDCard
* A generic analog light sensor based on an LDR
* Jumper cables
* USB -> Micro-USB cable

=== Software Prerequisites
* A code editor like Visual Studio Code
* Node.js (`v10` or higher installed - use `nvm` for easy switching between versions)
* Have `curl` installed
* Have Postgres installed (https://lisk.io/documentation/lisk-sdk/setup.html[Installation guide by Lisk]). Notice, we also talk about creating a lisk user on your system, for MacOS this is not needed.

=== Software

Three different kind of applications need to be developed, to create the decentralized supply chain system:

A node application::
which accepts the application-specific transaction types.
This application needs to be installed on different independent nodes and will setup and maintain the blockchain which is used to store the data about the packets, carrier and users.

A client application::
which is displaying information from the blockchain to the user.
It needs a frontend, which should be listing at least a list of packetIDs, the carrier, sender, recipient, and a status field (`pending | ongoing | alarm | success | fail`).
It should also provide an easy way to create and send the different transaction types to the network.

An IoT application::
which is stored on a microcontroller/raspberry pi. This application will track that the packet is not manipulated during the delivery.
To do this, certain sensors will be connected to it, that track information like light, temperature and/or humidity inside of the packet.
If something unexpected is detected by the IoT app, it will create a transaction object, sign it, and send it to the network.

== Part 1: Track a packet on the blockchain

The goal of this Part is to implement a simple application that tracks sensor measurements on the blockchain.
That means, once the IoT application will be started, it will immediately send an `LightAlarmTransaction` to the network, whenever the sensor detects light.

You will learn here:

* How to implement the `LightAlarmTransaction`
* How to register the new transaction type with the node application
* How to create a simple frontend for users to
** Initialize a new packet account
** Explore all posted alarm transactions

NOTE: For Part 1 of the workshop, it is not needed to check any status of the packet before sending an alarm transaction.

=== 1.0 Setup

Set up the needed software and hardware and installation of the dependencies.

==== Clone the repo and install the dependencies

The below steps describe how to create the initial files for this tutorial.

["loweralpha"]
. Clone https://github.com/LiskHQ/lisk-sdk-examples/[Lisk-SDK-Examples] repository locally.
+
[source,bash]
----
git clone https://github.com/LiskHQ/lisk-sdk-examples.git
cd lisk-sdk-examples
----
. Checkout branch `development` (by default active branch).
The basic file structure looks as following:
+
.Contents of `lisk-sdk-examples/transport`
----
.
├── README.adoc
├── Workshop.adoc
├── client <1>
│   ├── accounts.json
│   ├── app.js
│   ├── package.json
│   ├── scripts
│   └── views
├── iot <2>
│   ├── README.md
│   ├── lisk_rpi_ldr_and_temperature_sensors_wiring.png
│   ├── package_alarm
│   │   ├── package.json
│   │   └── packet_alarm.js
├── node <3>
│   ├── index.js
│   └── package.json
└── transactions <4>
    ├── finish-transport.js
    ├── light-alarm.js
    ├── register-packet.js
    └── start-transport.js
----
+
<1> Contains the code for the <<software, client application>>
<2> Contains the code for the <<software, IoT application>>
<3> Contains the code for the <<software, node application>>
<4> Contains the <<general-procedure, custom transactions>>
. Navigate inside `transport/node` folder and run `npm install` to install the required dependencies for the node application.
+
[source,bash]
----
cd transport/node
npm install
----
. Setup the database:
.. In case you have experimented before with Lisk, it is possible you have to first drop your database and recreate it with: `dropdb lisk_dev && createdb lisk_dev --owner lisk`.
.. If you set up the Lisk SDK for the first time, run the following 2 commands:
+
[source, bash]
----
createdb lisk_dev --owner lisk
psql -d lisk_dev -c "alter user lisk with password 'password';"
----
. To verify if the setup is correct, try to run the application with
+
[source,bash]
----
node index.js | npx bunyan -o short
----
This command will run the `index.js` file and pipe the outputted logs to our preferred log formatting tool Bunyan.

If everything is running fine, you can stop the node by hitting kbd:[CTRL+C].

==== Prepare the IoT device

[TIP]
====
These steps are already prepared for you before the workshop.

For reference, see how the sensors can be connected, and the steps to set up the Raspberry Pi below.
====

Wire the sensors::
image:iot/lisk_rpi_ldr_and_temperature_sensors_wiring.png[RPI Wiring, title="RPI Wiring"]

Preparing the Operating System::
The operating system for the Raspberry needs to be copied from a computer into an SD card for this we recommend using https://www.balena.io/etcher/ (good tutorial in https://medium.com/@ccarnino/backup-raspberry-pi-sd-card-on-macos-the-2019-simple-way-to-clone-1517af972ca5)
+
For preparing the Raspberry for `ssh` and wifi access follow this guide: https://core-electronics.com.au/tutorials/raspberry-pi-zerow-headless-wifi-setup.html
+
As we want to run the Raspberry in headless mode (i.e. no keyboard, mouse and monitor) we need to also enable `ssh` through USB.
To do so follow this guide https://desertbot.io/blog/ssh-into-pi-zero-over-usb
Once all those steps are followed the SD card can be unmounted and inserted into the Raspberry SD card reader.

Booting the Raspberry Pi::
Connect a micro usb cable with the Raspberry and then connect the other end to a computer.
+
First create a new ssh keypair.
Afterwards you should be able to log-in through ssh by running:
+
[source, bash]
----
ssh-keygen -R raspberrypi.local
ssh pi@raspberrypi.local
----
+
If the pi won't respond, press Ctrl-C and try the last command again
If prompted with a warning just hit enter to accept the default (Yes)
+
Type in the password -- by default this is `raspberry`

Installing required libraries for accessing sensor data::
The pins in the Raspberry need some libraries before they can be used for communicating with different sensors.
For installing the required libraries run:

* `sudo apt-get install wiringpi`
* `sudo apt-get install pigpio`
* NodeJS can be installed with `nvm`

=== 1.1 Implement the LightAlarm transaction

For the very simple version of the packet tracking, only one custom transaction type needs to be implemented: the `LightAlarmTransaction`.
This transaction will be sent by the IoT device inside of the packet, if it detects anomalies with its' connected photoresistor.

The only thing you need to implement yourself is the `validateAsset` function.

.Navigate into the `transactions/` directory
[source,bash]
----
cd ../transactions
----

.contents of light-alarm.js
[source,js]
----
const {
    BaseTransaction,
    TransactionError,
} = require('@liskhq/lisk-transactions');

/**
 * Send a light alarm when the packet has been opened.
 * Signed by packet.
 */
class LightAlarmTransaction extends BaseTransaction { <1>

    static get TYPE () {
        return 23; <2>
    }

    static get FEE () {
        return '0'; <3>
    };

    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId, <4>
            }
        ]);
    }

    validateAsset() { <5>
        const errors = [];
        /* Write your own logic for validateAsset() here */
        return errors;
    }

    applyAsset(store) { /* Insert the logic for applyAsset() here */ }

    undoAsset(store) {
        const errors = [];

        packet.asset.status = null;
        packet.asset.alarms.light.pop();

        store.account.set(packet.address, packet);
        return errors;
    }
}
module.exports = LightAlarmTransaction;
----

<1> Extend the new transaction type from the `BaseTransaction` interface.
<2> Set the transaction type (this has to be unique in the network).
<3> Set the transaction fee. This needs to be paid by the sender when posting the transaction to the network.
Set it to `0` for now, so the packet doesn't need any funds to send an alarm transaction.
<4> Cache the packet account. For the `LightAlarmTransaction`, we only need the packet account data.
<5> Static checks for presence and correct datatype of `timestamp`, which holds the timestamp of when the alarm was triggered.

prepare(store)::
The `prepare` function caches relevant data from the database.
This enables the application to work on a consistent data set, while applying the transaction logic.

validateAsset()::
Inside of `validateAsset`, the inputs are validated to ensure the required data is present and that is has the expected data type.
The `validateAsset` function is responsible for only performing static checks.
This means the function is synchronous and cannot use data from the key-value `store` (which holds the data that has been cached in the `prepare` function).
+
Therefore, we can only perform initial checks like validating the presence of the parameter and if the parameter has the correct type.
If validations fails, it shall create a new `TransactionError`, and push it into the `errors` array.
In case the function returns an array that contains errors, the transaction will be discarded.
+
The function for `TransactionError` is exported by `@liskhq/lisk-transactions`.
You can find the constructor https://github.com/LiskHQ/lisk-sdk/blob/development/elements/lisk-transactions/src/errors.ts#L22[here].
+
[source,js]
----
public constructor(
    message: string = '',
    id: string = '',
    dataPath: string = '',
    actual?: string | number,
    expected?: string | number,
) { ... }
----

applyAsset(store)::
Calls `store.get` to get all of the relevant data.
It applies all of the necessary changes from the received transaction to the affected account(s) by calling `store.set`.

undoAsset(store)::
Inverse of `applyAsset`.
In case the transaction needs to be reverted, due to a network fork.
Undoes all of the changes to the accounts applied by the `applyAsset` step.

A possible solution for implementing the logic of `LightAlarmTransaction` is displayed below.
In our very simple first version of the packet tracking, the transaction will add a new `status` field to the packet account and set its' value to `alarm`.
Additionally, it will create a list `alarms.light` and push the current timestamp to this array.

==== Task: Implement `validateAsset()`

Implement your own logic for the `validateAsset()` function.
It shall validate the timestamp that got sent by the `LightAlarmTransaction`.
Do do this, it needs to be checked, if the timestamp is present in the transaction object, and if it has the correct data type.
In case that an error is found, push a new `TransactionError` into the `errors` array and return it in the function.

==== Explanation: `applyAsset()`

A possible implementation of `applyAsset` for the `LightAlarmTransaction`. See detailed descriptions of the implementation below.

Copy the snippet and insert it in `light-alarm.js` to complete the implementation of the transaction type.

.Implementation of applyAsset()
[source,js]
----
applyAsset(store) {
    const errors = [];

    const packet = store.account.get(this.senderId);

    /**
     * Update the Packet account:
     * - set packet status to "alarm"
     * - add current timestamp to light alarms list
     */
    packet.asset.status = 'alarm';
    packet.asset.alarms = packet.asset.alarms ? packet.asset.alarms : {};
    packet.asset.alarms.light = packet.asset.alarms.light ? packet.asset.alarms.light : [];
    packet.asset.alarms.light.push(this.timestamp);

    store.account.set(packet.address, packet);

    return errors;
}
----

Inside of `applyAsset`, we can make use of the cached data from the `prepare` function, which is stored inside of the `store` parameter.

With `store.account.get(ADDRESS)` we now get the account data of the packet account.
We specify `this.senderId` as address, because the light alarm is always signed and sent by the packet itself.

Once we have the data present, it is possible to manipulate it as desired.

When all changes have been made, they are applied to the database by executing `store.account.set(ADDRESS, DATA);

Unlike in `validateAsset`, the `store` parameter is present here.
That means, inside of `applyAsset` it is possible to make dynamic checks against the existing data in the database.
As we do not need to this here, an empty `errors` array is returned at the end of the function.

==== Register the transaction with the node application

Now, that we have created the new custom transaction type `LightAlarmTransaction`, it needs to be registered with the node application.
Without this step, the nodes in the network wouldn't recognize the new transaction type and therefore wouldn't accept the transactions.

.Update node/index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
const LightAlarmTransaction = require('../transactions/light-alarm');

configDevnet.app.label = 'lisk-transport';

const app = new Application(genesisBlockDevnet, configDevnet);
app.registerTransaction(LightAlarmTransaction);

app
    .run()
    .then(() => app.logger.info('App started...'))
    .catch(error => {
        console.error('Faced error in application', error);
        process.exit(1);
    });

----

TIP: After the registration of a new transaction type, the node needs to be restarted to apply the changes.

// @TODO Mention that this file might look slightly different when you use Docker script

The node application is now ready to accept and process the new transaction type `LightAlarmTransaction`.
As next step, lets create a client application, that helps you explore the data on the blockchain.

=== 1.2 The client application

* Initalize the packet account
** Create the packet credentials
** send 1 Beddow to packet from the genesis account, to initliaze the packet account
* Light-alarm explorer: Displaying the LightAlarmTxs + packetID

=== 1.3 The IoT application

* Read the sensor in a certain interval
* Send LightAlarmTx, if light is detected
* Make script start automatically after boot

== Part 2: A simple supply chain tracking system

=== 2.1 Implement RegisterPacket, StartTransport and FinishTransport transactions

Describe how to implement the missing transaction types. Leave certain parts of the implementation up to the user.

==== a. Register the packet on the blockchain

For the next step in our prototype, we need to implement the `RegisterPacket` transaction.
This transaction will register a packet on the blockchain that is ready to be picked up by a delivery person. The transaction allows the package owner to define a couple of properties:

* `packetID`: The ID of the packet account (registered on Raspberry Pi).
* `postage`: The postage refers to a number of LSK tokens the carrier receives upon successful delivery of the packet. The postage is stored in the packet account's asset field.
* `security`: The security refers to a number of LSK tokens that the carrier should lock as a "security" before he can accept the packet for delivery. Upon successful delivery, the security will be unlocked again to the carriers balance.
* `minTrust`: This minimum trust property has been introduced to keep track of well-behaving/performing carriers. Whenever a carrier successfully delivers a packet, his trust will be increased by one. The package owner can set a minimal trust level for a carrier before he can accept the package for delivery. If a carrier has a lower trust than the minimal required trust level, he cannot accept the package for delivery.
* `recipientId`: This is maybe the most important field as it sets the recipient for the package.

For the `RegistePacketTransaction` we will guide you through the `undoAsset()` function and let you implement a small snippet of code yourself.

.contents of register-packet.js
[source,js]
----
const {
    BaseTransaction,
    TransactionError,
    utils
} = require('@liskhq/lisk-transactions');

/**
 * Register new package for sender and update package account.
 */
class RegisterPacketTransaction extends BaseTransaction {

    static get TYPE () {
        return 20;
    }

    static get FEE () {
        return '0';
    };

    async prepare(store) { <1>
        await store.account.cache([
            {
                address: this.asset.packetId,
            },
            {
                address: this.senderId,
            }
        ]);
    }

    validateAsset() { <2>
        // Static checks for presence of `packetId`, `postage`, `security`, and `minTrust`.
        const errors = [];
        if (!this.asset.packetId || typeof this.asset.packetId !== 'string') {
            errors.push(
                new TransactionError(
                    'Invalid "asset.packetId" defined on transaction',
                    this.id,
                    '.asset.packetId',
                    this.asset.packetId
                )
            );
        }
        if (!this.asset.postage || typeof this.asset.postage !== 'string') {
			errors.push(
				new TransactionError(
					'Invalid "asset.postage" defined on transaction',
					this.id,
					'.asset.postage',
					this.asset.postage,
					'A string value',
				)
			);
        }
        if (!this.asset.security || typeof this.asset.security !== 'string') {
			errors.push(
				new TransactionError(
					'Invalid "asset.security" defined on transaction',
					this.id,
					'.asset.security',
					this.asset.security,
					'A string value',
				)
			);
        }
        if (typeof this.asset.minTrust !== 'number' || isNaN(parseFloat(this.asset.minTrust)) || !isFinite(this.asset.minTrust)) {
			errors.push(
				new TransactionError(
					'Invalid "asset.minTrust" defined on transaction',
					this.id,
					'.asset.minTrust',
					this.asset.minTrust,
					'A number value',
				)
			);
		}
        return errors;
    }

    applyAsset(store) {
        const errors = [];
        const packet = store.account.get(this.asset.packetId); <3>

        if (!packet.asset.status) { <4>
            /* --- Modify sender account --- */
            /**
             * Update the sender account:
             * - Deduct the postage from senders' account balance
             */
            const sender = store.account.get(this.senderId);
            const senderBalancePostageDeducted = new utils.BigNum(sender.balance).sub(   <5>
                new utils.BigNum(this.asset.postage)
            );
            const updatedSender = {
                ...sender,
                balance: senderBalancePostageDeducted.toString(),    <6>
            };
            store.account.set(sender.address, updatedSender);

             /* --- Modify packet account --- */
            /**
             * Update the packet account:
             * - Add the postage to the packet account balance
             * - Add all important data about the packet inside the asset field:
             *   - recipient: ID of the packet recipient
             *   - sender: ID of the packet sender
             *   - carrier: ID of the packet carrier
             *   - security: Number of tokens the carrier needs to lock during the transport of the packet
             *   - postage: Number of tokens the sender needs to pay for transportation of the packet
             *   - minTrust: Minimal trust that is needed to be carrier for the packet
             *   - status: Status of the transport (pending|ongoing|success|fail)
             */
            const packetBalanceWithPostage = new utils.BigNum(packet.balance).add(   <7>
                new utils.BigNum(this.asset.postage)
            );

            const updatedPacketAccount = {
                ...packet,
                ...{
                    balance: packetBalanceWithPostage.toString(),
                    asset: {
                        recipient: this.recipientId,
                        sender: this.senderId,
                        security: this.asset.security,
                        postage: this.asset.postage,
                        minTrust: this.asset.minTrust,
                        status: 'pending',
                        carrier: null
                    }
                }
            };
            store.account.set(packet.address, updatedPacketAccount);
        } else {
            errors.push(
                new TransactionError(
                    'packet has already been registered',
                    packet.asset.status
                )
            );
        }
        return errors;
    }

    undoAsset(store) {
        const errors = [];

        /* --- Revert sender account --- */    <8>
        const sender = store.account.get(this.senderId);
        const senderBalanceWithPostage = new utils.BigNum(sender.balance).add(
            new utils.BigNum(this.asset.postage)
        );
        const updatedSender = {
            ...sender,
            balance: senderBalanceWithPostage.toString()
        };
        store.account.set(sender.address, updatedSender);

        /* --- Revert packet account --- */
        const packet = store.account.get(this.asset.packetId);
        const originalPacketAccount = { ...packet, balance: 0, asset: null };
        store.account.set(packet.address, originalPacketAccount);

        return errors;
    }

}

module.exports = RegisterPacketTransaction;
----

<1> Prepare function stores both sender and packet account in the cache so we can modify the accounts during the `applyAsset` and `undoAsset` steps.
<2> Static checks for presence and correct datatypes of transaction parameters in asset field like `minTrust`, `security`, `postage`, etc.
<3> Retrieve packet account from key-value store.
<4> Check if packet account already has a status assigned. If it has, this means the package is already registered so we throw an error.
<5> Deduct the defined postage from the sender's account balance.
<6> Save the updated sender account with the new balance into the key-value store.
<7> Add the postage now to the packet's account balance.
<8> UndoAsset function tells the blockchain how to rollback changes made in the applyAsset function. We restore the original balance for both the sender and package account. Also, we reset the `asset` field for the package account to `null` as it didn't hold any data at first.


undoAsset(store)::
The `undoAsset` function is responsible for telling the blockchain how to revert changes that have been applied via the `applyAsset` function. This is very useful in case of a fork where we have to change to a different chain. In order to accomplish this, we have to roll back blocks and apply new blocks of a new chain. This means, when rolling back blocks we have to update the account state of the affected accounts. That's the reason why you should never skip writing logic for the `undoAsset` function.

**TASK**: Read the implementation of the `undoAsset` function. You will notice a small part of the logic is missing where we reset the packet account to its original state. Copy paste the code below that resets the balance of the packet account to zero and assigns a null value to the asset field as it didn't exist when initially calling the `applyAsset` function.

[source,js]
----
const originalPacketAccount = { ...packet, balance: 0, asset: null };
----

==== b. Start the Transport
For the next step in our prototype, we need to implement the `StartTransport` transaction.
This transaction indicates the start of the transportation as the carrier picks up the package from the sender. 

When creating the `StartTransport` transaction, the carrier defines:

* `packetID`: The ID of the packet that the carrier is going to transport. The `packetId` is not send in the asset field but is assigned to the `recipientId` property of the transaction.

This transaction will:

* Lock the specified `security` of the packet in the carriers' account. This security cannot be accessed by the carrier, unless the transport has been finished successfully.
* Add the `carrier` to the packet account.
* Set the `status` of the packet from `pending` to `ongoing`.

For the `StartTransportTransaction` we will guide you through the `prepare()` and `undoAsset()` functions and let you implement the locking of the security in the carrier his account.

.contents of start-transport.js
[source,js]
----
const {
    BaseTransaction,
    TransactionError,
    utils
} = require('@liskhq/lisk-transactions');

class StartTransportTransaction extends BaseTransaction {

    static get TYPE () {
        return 21;
    }

    static get FEE () {
        //return `${10 ** 8}`;
        return '0';
    };

    async prepare(store) {     <1>
        await store.account.cache([
            {
                address: this.recipientId,
            },
            {
                address: this.senderId,
            }
        ]);
    }

    validateAsset() {     <2>
        const errors = [];

        return errors;
    }

    applyAsset(store) {
        const errors = [];
        const packet = store.account.get(this.recipientId);
        if (packet.asset.status === "pending"){
            const carrier = store.account.get(this.senderId);
            // If the carrier has the trust to transport the packet
            const carrierTrust = carrier.asset.trust ? carrier.asset.trust : 0;
            const carrierBalance = new utils.BigNum(carrier.balance);
            const packetSecurity = new utils.BigNum(packet.asset.security);
            if (packet.asset.minTrust <= carrierTrust && carrierBalance.gte(packetSecurity)) {           <3>
                /**
                 * Update the Carrier account:
                 * - Lock security inside the account
                 * - Remove the security form balance
                 * - initialize carriertrust, if not present already
                 */
                const carrierBalanceWithoutSecurity = carrierBalance.sub(packetSecurity);
                const carrierTrust = carrier.asset.trust ? carrier.asset.trust : 0;
                const updatedCarrier = {
                    ...carrier,
                    ...{
                        balance: carrierBalanceWithoutSecurity.toString(),
                        asset: {
                            trust: carrierTrust,
                            lockedSecurity: packet.asset.security,
                        }
                    }
                };
                store.account.set(carrier.address, updatedCarrier);
                /**
                 * Update the Packet account:
                 * - Set status to "ongoing"
                 * - set carrier to ID of the carrier
                 */
                packet.asset.status = "ongoing";     <4>
                packet.asset.carrier = carrier.address;
                store.account.set(packet.address, packet);
            } else {
                errors.push(
                    new TransactionError(
                        'carrier has not enough trust to deliver the packet, or not enough balance to pay the security',
                        packet.asset.minTrust,
                        carrier.asset.trust,
                        packet.asset.security,
                        carrier.balance
                    )
                );
            }
        } else {
            errors.push(
                new TransactionError(
                    'packet status needs to be "pending"',
                    packet.asset.status
                )
            );
        }

        return errors;
    }

    undoAsset(store) {
        const errors = [];
        const packet = store.account.get(this.recipientId);
        const carrier = store.account.get(this.senderId);
        /* --- Revert carrier account --- */
        const carrierBalanceWithSecurity = new utils.BigNum(carrier.balance).add(
            new utils.BigNum(packet.assset.security)
        );
        const updatedCarrier = {
            ...carrier,
            balance: carrierBalanceWithSecurity.toString()   <5>
        };
        store.account.set(carrier.address, updatedCarrier);
        /* --- Revert packet account --- */
        const updatedData = {
            asset: {
                deliveryStatus: "pending",        <6>
                carrier: null
            }
        };
        const newObj = {
            ...packet,
            ...updatedData
        };
        store.account.set(packet.address, newObj);
        return errors;
    }

}

module.exports = StartTransportTransaction;
----

<1> We both cache the `senderId` which is the carrier account and the `recipientId` which is the packet account in the `prepare` function.
<2> We don't need any static validation as there is no data being sent in the `asset` field.
<3> Check if the carrier has the minimal trust required for accepting the package. Also, we check if the carrier his balance is larger than the required security as we need to lock this security from the carrier's account balance.
<4> Next, we lock the defined security (number of LSK tokens) in the asset field under the property `lockedSecurity` and deducted this security from his `carrierBalance`.
<5> For the `undoAsset` function, we need to revert the steps of `applyAsset` again. This means we need to remove the locked balance in the `asset` field and add this number again to the `balance` of the carrier's account.
<6> For the packet account, we need to undo some items as well. First of all, we need to set the `deliveryStatus` again to `pending`.

Lock Funds (applyAsset)::
Locking funds is actually very straightforward. First, you deduct the number of tokens you want to lock from the account's balance. Next, you store the deducted number of tokens in a custom property in the asset field so we can later know how much tokens we had locked as a security. 

Undoing the locked tokens can be done by removing the custom property in the `asset` field and adding the number of tokens again to the account's balance.

**TASK**: There is some code missing for the `undoAsset` function where we reset the carrier's balance. Add the following snippet to the `const updatedCarrier` which sets the balance to the original balance.

[source,js]
----
const updatedCarrier = {
    ...carrier,
    balance: carrierBalanceWithSecurity.toString()
};
----

==== c. Finish the Transport

=== 2.2 Extend the client application
Add the following features to the web application from <<part-1-track-a-packet-on-the-blockchain, Part 1: Track a packet on the blockchain>>

* POST RegisterPacket, StartTransport and FinishTransport Transactions
* Explorer of registered Packets and Carriers, displaying `packet.asset` data

=== 2.3 Test it out!

==== Test run on local blockchain

A full test run of the supply chain tracking workflow with the blockchain application

==== Connecting multiple nodes

This sections explains how to connect several nodes to your blockchain, and how to exchange the dummydelegates with real ones.

==== Writing unit tests for custom transactions

How to test `undoAsset` functions
