= Workshop: Lisk Transport
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:experimental:

== Motivation

One reason why the modern world is seeing more and more wealth created is because the economies and markets are connected via ever more sophisticated routes of global trade.
Whether be it by air, sea, or road, billions worth of goods are being taken from continent to continent every single day, in order to satisfy demand and meet supply quotas.
However, while new methods of storage and route tweaks are still developed in order to further propel this vital aspect of the global economy, the sheer volume of transport information processed on a daily basis means there is huge inaccuracy of data when trying to monitor an individual product’s journey.
Major business leaders depending on physical supply chains have long pushed for more transparency, price-efficiency and data insight, starting at the creation of a product to its final destination.

Applying blockchain to a supply chain could resolve these problems by creating a permanent history of a product.
This can have many industry-spanning benefits - reducing costs, pinpointing human error and avoiding delays.
All of this could potentially save years of time and billions of dollars in overhead.
Vendors and suppliers could benefit from a greater insight into the manufacturing process of the goods they use, being able to use the decentralized supply ledger in order to investigate variables such as delivery or maintenance of products.
For certain industries where high maintenance of goods in the supply chain is especially crucial, we can envision how blockchain can step in in order to ensure that quality targets are being met.
For example, medical or aerospace science industries could easily utilise blockchain supply chain in order to ensure the parts and chemicals they use in their work come from a reputable source and have had all the necessary storage requirements met in the journey to its final destination.

Retail giants on another hand, can be one of the primary examples of blockchain use cases if we consider how the immutable, trustless nature of a supply chain can be used to crack down on the ethical implications of how some of the raw foods are being sourced, but also improve quality and investigate where the spoiled food came from and how it got on the store shelf.
Insights like these help today’s retailers improve storage and farming techniques in order to raise the food standard for the end customer as well as reduce the amount of food waste that does not meet contemporary health and safety regulation requirements.

image::blockchain-supply-chain.jpg[Blockchain Supply Chain]

=== Conclusion

To conclude, blockchain can benefit supply chain and transport industries by introducing a new level of data transparency and responsiveness that helps to improve processes and attracts potential clients.
On another hand, applying blockchain to certain supply chains can benefit the end consumer, primary producer, and any other party inbetween, through better insights about how any product came to be.

Supply chains of the future are poised to continue being more responsive, efficient and flexible than their contemporaries.
With the global trade networks at stake, blockchain will help flesh out the correct pathways for goods to travel from continent to continent and from producer to end customer.

== Idea

The goal is to create a simple decentralized supply chain tracking system.
The participants of the network can send, transport and receive packets with each other.

For the transportation of the packet, a simple trust system is implemented, that enables the sender to set certain requirements for the carrier of the packet.
The packet as well will be an active participant in the transportation process, as it will track itself with sensors during the transportation.
This is to ensure, that it hasn't been manipulated during the transport.

The carrier will be rewarded upon successful transportation, and penalized if the transportation has failed for some reason.

For convenient usage of the system, a client application will be provided, that visualizes all relevant information about the supply chain tracking system, and that let's users interact with the system by posting custom transactions.

=== General procedure

This diagram shows the general workflow of the supply chain tracking system.
You find detailed descriptions of each step below.

image::transport-uml.svg[Flow chart of Lisk Transport]

==== Initliaze packet account

Before registering the packet on the network, the sender needs to create a new account for the packet and store the passphrase on the IoT device inside the packet.
This is necessary, because the packet needs to sign the transactions it sends to the network, in order to communicate with it.

==== Register packet

The packets are registered on the blockchain network by the packet sender.

When creating the `RegisterPacketTransaction`, the sender defines:

* `packetId`: The ID of the packet that has been initialized in the step before.
* `postage`: This amount will be paid to the carrier for the transport of the packet.
* `security`: The security is the amount of tokens that will be locked on the carrier account, when the carrier receives the packet form the sender
* `minTrust`: The minimum amount of trust a carrier needs to have, to transport this packet
* `recipientId`: The ID of the desired recipient of the packet. Only the recipient can send the `FinishTransaction` later, which will finish the transport.

This transaction will:

 * add the above data to the packet account.
 * set the `status` of the packet to `pending`.
 * transfer the postage from the senders' account to the packet account.

==== Start transport

As next step, a carrier would go to the packet senders' address, receive the packet and start the delivery to the recipient.
The carrier needs to sign a transaction `StartTransportTransaction`, that verifies that the packet has been passed on to the carrier.

When creating the `StartTransportTransaction`, the carrier defines:

* `packetID`: The ID of the packet that the carrier is going to transport.

This transaction will:

* lock the specified `security` of the packet in the carriers' account.
This security cannot be accessed by the carrier, unless the transport has been finished successfully.
* add the `carrier` to the packet account.
* set the `status` of the packet from `pending` to `ongoing`.

==== Light alarm

During the transportation of the packet, the packet will track itself with different sensors, to check if it gets manipulated during the travel.
If a manipulation is detected, it will send a self-signed alarm transaction to the network.

This `LightAlarmTransaction` will:

* change the packets' `status` to `alarm`
* Add the current `timestamp` to the list `asset.alarms.light` inside of the packet account.

==== Finish transport

When reaching the recipient of the packet, the carrier passes the packet to the recipient.
The recipient needs to sign the `FinishTransportTransaction`, that verifies that the packet has been passed on to the recipient.

When sending the transaction, the recipient needs to specify:

* `packetID`: The ID of the packet that the recipient received
* `status`: The status of the transport, which has 2 options: `"success"` or `"fail"`

This transaction will:

* If `status="success"`
** Send `postage` to carrier account
** Unlock `security` in carrier account
** Increase `trust` of carrier +1
** Set packet `status` to `success`
* If `status="fail"`
** Send `postage` to sender account
** Add `security` to the sender account, and nullify `lockedSecurity` from the account fo the carrier.
** Decrease `trust` of carrier by -1
** Set packet `status` to `fail`

== Requirements

=== Hardware

==== Hardware to bring yourself
* Laptop with one of the following OS installed:
** Ubuntu 16.04 (LTS) x86_64
** Ubuntu 18.04 (LTS) x86_64
** MacOS 10.13 (High Sierra)
** MacOS 10.14 (Mojave)

==== Hardware provided
* Raspberry Pi Zero W (running a headless Raspbian Buster lite)
* 16GB class 10 SDCard
* A generic analog light sensor based on an LDR
* Jumper cables
* USB -> Micro-USB cable

=== Software Prerequisites
* A code editor like Visual Studio Code
* Node.js (`v10` or higher installed - use `nvm` for easy switching between versions)
* Have `curl` installed
* Have Postgres installed (https://lisk.io/documentation/lisk-sdk/setup.html[Installation guide by Lisk]). Notice, we also talk about creating a lisk user on your system, for MacOS this is not needed.

=== Software

Three different kind of applications need to be developed, to create the decentralized supply chain system:

A node application::
which accepts the application-specific transaction types.
This application needs to be installed on different independent nodes and will setup and maintain the blockchain which is used to store the data about the packets, carrier and users.

A client application::
which is displaying information from the blockchain to the user.
It needs a frontend, which should be listing at least a list of packetIDs, the carrier, sender, recipient, and a status field (`pending | ongoing | alarm | success | fail`).
It should also provide an easy way to create and send the different transaction types to the network.

An IoT application::
which is stored on a microcontroller/raspberry pi. This application will track that the packet is not manipulated during the delivery.
To do this, certain sensors will be connected to it, that track information like light, temperature and/or humidity inside of the packet.
If something unexpected is detected by the IoT app, it will create a transaction object, sign it, and send it to the network.

== Part 1: Track a packet on the blockchain

The goal of this Part is to implement a simple application that tracks sensor measurements on the blockchain.
That means, once the IoT application will be started, it will immediately send an `LightAlarmTransaction` to the network, whenever the sensor detects light.

You will learn here:

* How to implement the `LightAlarmTransaction`
* How to register the new transaction type with the node application
* How to create a simple frontend for users to
** Initialize a new packet account
** Explore all posted alarm transactions

NOTE: For Part 1 of the workshop, it is not needed to check any status of the packet before sending an alarm transaction.

=== 1.0 Setup

Set up the needed software and hardware and installation of the dependencies.

==== Clone the repo and install the dependencies

The below steps describe how to create the initial files for this tutorial.

["loweralpha"]
. Clone https://github.com/LiskHQ/lisk-sdk-examples/[Lisk-SDK-Examples] repository locally.
+
[source,bash]
----
git clone https://github.com/LiskHQ/lisk-sdk-examples.git
cd lisk-sdk-examples
----
. Checkout branch `development` (by default active branch).
The basic file structure looks as following:
+
.contents of lisk-sdk-examples/transport
----
.
├── README.adoc
├── Workshop.adoc
├── client <1>
│   ├── accounts.json
│   ├── app.js
│   ├── package.json
│   ├── scripts
│   └── views
├── iot <2>
│   ├── README.md
│   ├── lisk_rpi_ldr_and_temperature_sensors_wiring.png
│   ├── package_alarm
│   │   ├── package.json
│   │   └── packet_alarm.js
├── node <3>
│   ├── index.js
│   └── package.json
└── transactions <4>
    ├── finish-transport.js
    ├── light-alarm.js
    ├── register-packet.js
    └── start-transport.js
----
+
<1> Contains the code for the <<software, client application>>
<2> Contains the code for the <<software, IoT application>>
<3> Contains the code for the <<software, node application>>
<4> Contains the <<general-procedure, custom transactions>>
. Navigate inside `transport/node` folder and run `npm install` to install the required dependencies for the node application.
+
[source,bash]
----
cd transport/node
npm install
----
. Setup the database:
.. In case you have experimented before with Lisk, it is possible you have to first drop your database and recreate it with: `dropdb lisk_dev && createdb lisk_dev --owner lisk`.
.. If you set up the Lisk SDK for the first time, run the following 2 commands:
+
[source, bash]
----
createdb lisk_dev --owner lisk
psql -d lisk_dev -c "alter user lisk with password 'password';"
----
. To verify if the setup is correct, try to run the application with
+
[source,bash]
----
node index.js | npx bunyan -o short
----
This command will run the `index.js` file and pipe the outputted logs to our preferred log formatting tool Bunyan.

If everything is running fine, you can stop the node by hitting kbd:[CTRL+C].

==== Prepare the IoT device

[TIP]
====
These steps are already prepared for you before the workshop.

For reference, see how the sensors can be connected, and the steps to set up the Raspberry Pi below.
====

Wire the sensors::
image:iot/lisk_rpi_ldr_and_temperature_sensors_wiring.png[RPI Wiring, title="RPI Wiring"]

Preparing the Operating System::
The operating system for the Raspberry needs to be copied from a computer into an SD card for this we recommend using https://www.balena.io/etcher/ (good tutorial in https://medium.com/@ccarnino/backup-raspberry-pi-sd-card-on-macos-the-2019-simple-way-to-clone-1517af972ca5)
+
For preparing the Raspberry for `ssh` and wifi access follow this guide: https://core-electronics.com.au/tutorials/raspberry-pi-zerow-headless-wifi-setup.html
+
As we want to run the Raspberry in headless mode (i.e. no keyboard, mouse and monitor) we need to also enable `ssh` through USB.
To do so follow this guide https://desertbot.io/blog/ssh-into-pi-zero-over-usb
Once all those steps are followed the SD card can be unmounted and inserted into the Raspberry SD card reader.

Booting the Raspberry Pi::
Connect a micro usb cable with the Raspberry and then connect the other end to a computer.
+
First create a new ssh keypair.
Afterwards you should be able to log-in through ssh by running:
+
[source, bash]
----
ssh-keygen -R raspberrypi.local
ssh pi@raspberrypi.local
----
+
If the pi won't respond, press Ctrl-C and try the last command again
If prompted with a warning just hit enter to accept the default (Yes)
+
Type in the password -- by default this is `raspberry`

Installing required libraries for accessing sensor data::
The pins in the Raspberry need some libraries before they can be used for communicating with different sensors.
For installing the required libraries run:
+
* `sudo apt-get install wiringpi`
* `sudo apt-get install pigpio`
* NodeJS can be installed with `nvm`

=== 1.1 Implement the LightAlarm transaction

For the very simple version of the packet tracking, only one custom transaction type needs to be implemented: the `LightAlarmTransaction`.
This transaction will be send by the IoT device inside of the packet, if it detects anomalies with its' connected photoresistor.

The only thing you need to insert yourself is the `applyAsset` function.

.Navigate into the `transactions/` directory
[source,bash]
----
cd ../transactions
----

.contents of light-alarm.js
[source,js]
----
const {
    BaseTransaction,
    TransactionError,
} = require('@liskhq/lisk-transactions');

/**
 * Send a light alarm when the packet has been opened.
 * Signed by packet.
 */
class LightAlarmTransaction extends BaseTransaction { <1>

    static get TYPE () {
        return 23; <2>
    }

    static get FEE () {
        return '0'; <3>
    };

    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId, <4>
            }
        ]);
    }

    validateAsset() { <5>
        const errors = [];
        if (!this.timestamp || typeof this.timestamp !== 'number') {
            errors.push(
                new TransactionError(
                    'Invalid ".timestamp" defined on transaction',
                    this.id,
                    '.timestamp',
                    this.timestamp
                )
            );
        }
        return errors;
    }

    applyAsset(store) { /* Write the logic for applyAsset() here */ }

    undoAsset(store) {
        const errors = [];

        packet.asset.status = null;
        packet.asset.alarms.light.pop();

        store.account.set(packet.address, packet);
        return errors;
    }
}
module.exports = LightAlarmTransaction;
----

<1> Extend the new transaction type from the `BaseTransaction` interface.
<2> Set the transaction type (this has to be unique in the network).
<3> Set the transaction fee. This needs to be paid by the sender when posting the transaction to the network.
Set it to `0` for now, so the packet doesn't need any funds to send an alarm transaction.
<4> Cache the packet account. For the `LightAlarmTransaction`, we only need the packet account data.
<5> Static checks for presence and correct datatype of `timestamp`, which holds the timestamp of when the alarm was triggered.

prepare(store)::
The `prepare` function caches relevant data from the database.
This enables the application to work on a consistent data set, while applying the transaction logic.

validateAsset()::
Inside of `validateAsset`, the inputs are validated to ensure the required data is present and that is has the expected data type.

applyAsset(store)::
Calls `store.get` to get all of the relevant data.
It applies all of the necessary changes from the received transaction to the affected account(s) by calling `store.set`.

undoAsset(store)::
Inverse of `applyAsset`.
In case the transaction needs to be reverted, due to a network fork.
Undoes all of the changes to the accounts applied by the `applyAsset` step.

A possible solution for implementing the logic of `LightAlarmTransaction` is displayed below.
In our very simple first version of the packet tracking, the transaction will add a new `status` field to the packet account and set its' value to `alarm`.
Additionally, it will create a list `alarms.light` and push the current timestamp to this array.

.Implementation of applyAsset()
[source,js]
----
applyAsset(store) {
    const errors = [];

    const packet = store.account.get(this.senderId);

    /**
     * Update the Packet account:
     * - set packet status to "alarm"
     * - add current timestamp to light alarms list
     */
    packet.asset.status = 'alarm';
    packet.asset.alarms = packet.asset.alarms ? packet.asset.alarms : {};
    packet.asset.alarms.light = packet.asset.alarms.light ? packet.asset.alarms.light : [];
    packet.asset.alarms.light.push(this.timestamp);

    store.account.set(packet.address, packet);

    return errors;
}
----

Copy the snippet above and insert it in `light-alarm.js` to complete the implementation of the transaction type.
Now, that we have created the new custom transaction type `LightAlarmTransaction`, it needs to be registered with the node application.
Without this step, the nodes in the network wouldn't recognize the new transaction type and therefore wouldn't accept the transactions.

.Update node/index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
const LightAlarmTransaction = require('../transactions/light-alarm');

configDevnet.app.label = 'lisk-transport';

const app = new Application(genesisBlockDevnet, configDevnet);
app.registerTransaction(LightAlarmTransaction);

app
    .run()
    .then(() => app.logger.info('App started...'))
    .catch(error => {
        console.error('Faced error in application', error);
        process.exit(1);
    });

----

TIP: After the registration of a new transaction type, the node needs to be restarted to apply the changes.

The node application is now ready to accept and process the new transaction type `LightAlarmTransaction`.
As next step, lets create a client application, that helps you explore the data on the blockchain.

=== 1.2 The client application

* Initalize the packet account
** Create the packet credentials
** send 1 Beddow to packet from the genesis account, to initliaze the packet account
* Light-alarm explorer: Displaying the LightAlarmTxs + packetID

=== 1.3 The IoT application

* Read the sensor in a certain interval
* Send LightAlarmTx, if light is detected
* Make script start automatically after boot

== Part 2: A simple supply chain tracking system

=== 2.1 Implement RegisterPacket, StartTransport and FinishTransport transactions

Describe how to implement the missing transaction types. Leave certain parts of the implementation up to the user.

==== a. Register the packet on the blockchain

==== b. Start the Transport

==== d. Finish the Transport

=== 2.2 Extend the client application
Add the following features to the web application from <<part-1-track-a-packet-on-the-blockchain, Part 1: Track a packet on the blockchain>>

* POST RegisterPacket, StartTransport and FinishTransport Transactions
* Explorer of registered Packets and Carriers, displaying `packet.asset` data

=== 2.3 Test it out!

==== Test run on local blockchain

A full test run of the supply chain tracking workflow with the blockchain application

==== Connecting multiple nodes

This sections explains how to connect several nodes to your blockchain, and how to exchange the dummydelegates with real ones.

==== Writing unit tests for custom transactions

How to test `undoAsset` functions
