= Lisk Transport
Mona Bärenfänger <mona@lightcurve.io>
:toc:

Lisk Transport is a PoC (Proof of Concept) blockchain application, to showcase the features and capabilities of the Lisk SDK (alpha).

== Idea

The goal is to create a simple decentralized supply chain tracking system.

Before registering the packet on the network, the sender needs to create a new account for the packet and store the passphrase on the IoT device inside the packet.
This is necessary, because the packet needs to sign the transactions it sends to the network, in order to communicate with it.
The packets are registered on the blockchain network by the packet sender.

As next step, a carrier would go to the packet senders' address, receive the packet and start the delivery to the recipient.
The carrier needs to sign a transaction, that verifies that the packet has been passed on to the carrier.
With this transaction, the Carrier will lock a certain amount of tokens in his account, that was defined by the packet sender when registering the packet on the network.

During the transportation of the packet, the packet will track itself, to check if it gets manipulated during the travel.
If a manipulation is detected, it will send a self-signed alarm transaction to the network.

When reaching the recipient of the packet, the carrier passes the packet to the recipient.
The recipient needs to sign a transaction, that verifies that the packet has been passed on to the recipient.

image::transport-uml.svg[Flow chart of Lisk Transport]

== Requirements

=== Software

To achieve this, 3 different kind of applications need to be developed:

A blockchain application::
which accepts the application-specific <<_custom_transactions, transaction types>>.
This application needs to be installed on different independent nodes and will setup and maintain the blockchain which is used to store the data about the packets, carrier and users.
A client application::
which is displaying information from the blockchain to the user.
It needs a frontend, which should be listing at least a list of packetIDs, the carrier, sender, recipient, and a status field (`pending | ongoing | alarm | success | fail`).
It should also provide an easy way to create and send the different transaction types to the network.
An IoT application::
which is stored on a microcontroller/raspberry pi. This application will track that the packet is not manipulated during the delivery.
To do this, certain sensors will be connected to it, that track information like light, temperature and/or humidity inside of the packet.
If something unexpected is detected by the IoT app, it will create a transaction object, sign it, and send it to the network.

=== Hardware

* https://buyzero.de/collections/raspberry-pi-zero-kits/products/raspberry-pi-zero-w?variant=38399156114[Raspberry Pi Zero W]
* https://www.raspberrypi.org/documentation/installation/sd-cards.md[SD card]
* https://www.amazon.de/PEMENOL-Fotowiderstand-Anschl%C3%BCsse-Photodetektor-Comperator/dp/B07DP1YM5X/ref=sr_1_1?keywords=ldr+modul&qid=1569485546&s=gateway&sr=8-1[Photoresistor]
* https://www.amazon.de/Female-Female-Male-Female-Male-Male-Steckbr%C3%BCcken-Drahtbr%C3%BCcken-bunt/dp/B01EV70C78/ref=sr_1_5?keywords=dupont+kabel&qid=1569485735&s=gateway&sr=8-5[Jumper cables]
* https://www.amazon.de/AZDelivery-AM2302-Temperatursensor-Luftfeuchtigkeitssensor-Arduino/dp/B06XF4TNT9/ref=sr_1_1_sspa?crid=35G9VO3PY15BQ&keywords=dht22&qid=1569485584&s=gateway&sprefix=dht%2Caps%2C153&sr=8-1-spons&psc=1&smid=A1X7QLRQH87QA3&spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEzOE1YSzU4WlBZUDdVJmVuY3J5cHRlZElkPUEwODAwMjUwMUNNRkdEQUNQUTJYUCZlbmNyeXB0ZWRBZElkPUEwNzEwNjA5VTJNSlFXNjM5RzAzJndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==[Temp/Humidity sensor]
* USB -> Micro-USB cable
* Battery/Powerbank

== Connecting to the Raspberry Pi

To simplify the network setup for the workshop we're going to use ssh over USB. During the workshop the Raspberry Pi will also be connected 
to the internet, thruough its own wifi, to be able to use npm. 

Each Raspberry Pi has it's own hostname printed in the box and a password for the default `pi` user.

==== Connecting
- connect the micro-usb plug of the provided cable to the usb socket labeled `usb` (wait for about a minute and a half)
- run the command `ssh pi@<the hostname of your Pi here>` and when asked enter the password for your Pi

=== Custom Transactions

lightAlarmTransaction::
* Signed by: Packet
* Required data: timestamp
* Description: If light is detected by the photoresistor inside the packet, the packet sends this transaction to the network.
This transaction should only go off, when the packet is traveling (status should be `ongoing` or `alarm`).
It will save the current timestamp to the packet accounts' alarms list ad change the status to `alarm`.

registerPacketTransaction::
* Signed by: Sender
* Required data: packetID, receiverID, postage, security, minTrust
* Altered data: `status="pending"`, describes the current status of the transport inside the packet account.
* Description: Register packet on the network.
A separate account for the packet will be created.
** `status`: the status of the transport
** `recipient` the ID of the recipient in the network (to verify succesful delivery later).
** `postage` needs to be paid by the sender, and is stored in the account of the packet.
The `postage` will be paid to the carriers account, after successful delivery of the packet.
** `security` is the number of tokens a carrier has to lock as a security, before carrying the packet.
Will be unlocked on successful delivery of the packet.
** `minTrust` is the minimum trust that is needed, to register as a carrier for this packet.

startTransportTransaction::
* Signed by: Carrier
* Required data: packetID
* Altered data: `status="ongoing"`, describes the current status of the delivery inside the packet account.
* Description: Defines start time of the packet delivery.
`security` will get deducted form the carrier account and added to the packet account.
The `carrierID` is added to the packet account.
This transaction should fail, if the Carrier does not fulfill the requirements in terms of trust and security, that the sender defined as a minimum in the `registerPackageTransaction`.

finishTransportTransaction::
* Signed by: Recipient
* Required data: packetID, status="success"|"fail"
* Altered data: `deliveryStatus="successful|failed"`, describes the status of the delivery inside the packet account.
** `successful` if packet was delivered in estimated timespan.
** `failed`, if the packet does not arrive.
* Description: Defines the end of the packet transport.
** If the delivery is successful:
*** The Carrier receives the postage tokens on successful transportation of the packet.
*** The Carrier receives a certain amount of trust-points.
** If the delivery fails, the Carrier can be punished:
*** Security tokens and Postage will be transferred to packet Sender
*** Deduction of trust points from the Carrier
